{"version":3,"names":["_regeneratorDefine","require","_regenerator","undefined","$Symbol","Symbol","iteratorSymbol","iterator","toStringTagSymbol","toStringTag","_","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","prototype","Generator","generator","Object","create","define","makeInvokeMethod","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","getPrototypeOf","IteratorPrototype","Gp","displayName","mark","genFun","setPrototypeOf","__proto__","state","invoke","_methodName","_method","_arg","TypeError","done","Context_dispatchExceptionOrFinishOrAbrupt","method","arg","delegateIterator","ctx","v","n","call","value","e","tryEntries","p","a","f","bind","d","iterable","nextLoc","_type","shouldReturn","length","entry","prev","finallyLoc","exports","default","w","m"],"sources":["../../src/helpers/regenerator.ts"],"sourcesContent":["/* @minVersion 7.27.0 */\n/* @mangleFns */\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n\nimport define from \"./regeneratorDefine.ts\";\n\nconst enum GenState {\n  SuspendedStart,\n  SuspendedYieldOrCompleted,\n  Executing,\n}\n\nconst enum OperatorType {\n  Next,\n  Throw,\n  Return,\n  Jump,\n  Finish,\n}\n\nconst enum ContextNext {\n  End = -1,\n}\n\ntype TryLocs = [\n  tryLoc: number,\n  catchLoc?: number,\n  finallyLoc?: number,\n  afterLoc?: number,\n];\n\ntype TryEntry = [\n  ...TryLocs,\n  recordType?: OperatorType.Throw | OperatorType.Jump | OperatorType.Return,\n  recordArg?: any,\n];\n\ntype Context = {\n  // prev\n  p: number;\n  // next\n  n: number;\n  // value\n  v: any;\n\n  // abrupt\n  a(type: OperatorType, arg?: any): any;\n  // finish\n  f(finallyLoc: number): any;\n  // delegateYield\n  d(iterable: any, nextLoc: number): any;\n};\n\nexport default function /* @no-mangle */ _regenerator() {\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\n\n  var undefined: undefined; // More compressible than void 0.\n  var $Symbol =\n    typeof Symbol === \"function\" ? Symbol : ({} as SymbolConstructor);\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  var _: any;\n\n  function wrap(\n    innerFn: (this: unknown, context: Context) => unknown,\n    outerFn: Function,\n    self: unknown,\n    tryLocsList: TryLocs[],\n  ) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator =\n      outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    define(\n      generator,\n      \"_invoke\",\n      makeInvokeMethod(innerFn, self, tryLocsList),\n      true,\n    );\n\n    return generator;\n  }\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  /* @no-mangle */\n  function Generator() {}\n  /* @no-mangle */\n  function GeneratorFunction() {}\n  /* @no-mangle */\n  function GeneratorFunctionPrototype() {}\n\n  _ = Object.getPrototypeOf;\n  var IteratorPrototype = [][iteratorSymbol as typeof Symbol.iterator]\n    ? // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      _(_([][iteratorSymbol as typeof Symbol.iterator]()))\n    : // This is a polyfill for %IteratorPrototype% for environments that\n      // don't natively support it.\n      (define((_ = {}), iteratorSymbol, function (this: unknown) {\n        return this;\n      }),\n      _);\n\n  var Gp =\n    (GeneratorFunctionPrototype.prototype =\n    Generator.prototype =\n      Object.create(IteratorPrototype));\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n  define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  define(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function (this: Generator) {\n    return this;\n  });\n\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n\n  function mark(genFun: Function) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      // @ts-expect-error assign to __proto__\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }\n\n  function makeInvokeMethod(\n    innerFn: Function,\n    self: unknown,\n    tryLocsList: TryLocs[],\n  ) {\n    var state = GenState.SuspendedStart;\n\n    function invoke(\n      _methodName: \"next\" | \"throw\" | \"return\",\n      _method: OperatorType.Next | OperatorType.Throw | OperatorType.Return,\n      _arg: any,\n    ) {\n      if (state > 1 /* Executing */) {\n        throw TypeError(\"Generator is already running\");\n      } else if (done) {\n        if (_method === OperatorType.Throw) {\n          Context_dispatchExceptionOrFinishOrAbrupt(_method, _arg);\n        }\n      }\n\n      method = _method;\n      arg = _arg;\n\n      while ((_ = method < 2 /* Next | Throw */ ? undefined : arg) || !done) {\n        if (!delegateIterator) {\n          if (!method /* Next */) {\n            ctx.v = arg;\n          } else if (method < 3 /* Throw | Return */) {\n            if (method > 1 /* Return */) ctx.n = 